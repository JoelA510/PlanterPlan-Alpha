// Remove the uuid import since we're not using tokens
// import { v4 as uuidv4 } from 'uuid';

// src/services/invitationService.js
import { supabase } from '../supabaseClient';

/**
 * Get user by email address
 * @param {string} email - Email address to search for
 * @returns {Promise<{data: Object, error: string}>} - User data or error
 */
export const getUserByEmail = async (email) => {
    try {
      console.log('Looking up user by email:', email);
      
      if (!email) {
        return { data: null, error: 'Email is required' };
      }
      
      const { data, error } = await supabase
        .from('users')
        .select('id, email, first_name, last_name')
        .eq('email', email.toLowerCase())
        .single();
      
      if (error) {
        if (error.code === 'PGRST116') {
          // No user found - this is not necessarily an error for invitation checking
          console.log('No user found with email:', email);
          return { data: null, error: null };
        }
        console.error('Error looking up user by email:', error);
        return { data: null, error: error.message };
      }
      
      console.log('User found:', data);
      return { data, error: null };
    } catch (err) {
      console.error('Error in getUserByEmail:', err);
      return { data: null, error: err.message || 'Unknown error occurred' };
    }
  };

  
/**
 * Create a new project invitation (simplified - ignoring tokens)
 * @param {string} projectId - ID of the project
 * @param {string} email - Email address to invite
 * @param {string} role - Role to assign ('owner', 'full_user', 'limited_user', 'coach')
 * @param {string} invitedBy - ID of user sending the invitation
 * @returns {Promise<{data: Object, error: string}>} - The created invitation or error
 */
export const createInvitation = async (projectId, email, role, invitedBy) => {
  try {
    console.log('Creating invitation:', { projectId, email, role, invitedBy });
    
    // Validate inputs
    if (!projectId || !email || !role || !invitedBy) {
      return { error: 'Missing required fields for invitation' };
    }
    
    // Validate email format
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
      return { error: 'Invalid email address' };
    }
    
    // Validate role
    const validRoles = ['owner', 'full_user', 'limited_user', 'coach'];
    if (!validRoles.includes(role)) {
      return { error: 'Invalid role specified' };
    }
    const invitedUser = await getUserByEmail(email);
    
    // Check if user is already a member of this project
    const { data: existingMember, error: memberError } = await supabase
      .from('project_memberships')
      .select('id')
      .eq('project_id', projectId)
      .eq('user_id', invitedUser.data.id || null)
      .single();
    
    if (memberError && memberError.code !== 'PGRST116') {
      console.error('Error checking existing membership:', memberError);
      return { error: 'Error checking existing membership' };
    }
    
    if (existingMember) {
      return { error: 'User is already a member of this project' };
    }
    
    // Check if there's already a pending invitation for this email/project
    const { data: existingInvitation, error: inviteError } = await supabase
      .from('project_invitations')
      .select('id, status')
      .eq('project_id', projectId)
      .eq('email', email.toLowerCase())
      .eq('status', 'pending')
      .single();
    
    if (inviteError && inviteError.code !== 'PGRST116') {
      console.error('Error checking existing invitation:', inviteError);
      return { error: 'Error checking existing invitation' };
    }
    
    if (existingInvitation) {
      return { error: 'An invitation is already pending for this email address' };
    }
    
    // Set expiration (7 days from now)
    const expiresAt = new Date();
    expiresAt.setDate(expiresAt.getDate() + 7);
    
    // Create the invitation (letting database generate token automatically)
    const invitationData = {
      project_id: projectId,
      email: email.toLowerCase(),
      role: role,
      invited_by: invitedBy,
      expires_at: expiresAt.toISOString(),
      status: 'pending'
      // invitation_token will be auto-generated by database
    };
    
    const { data, error } = await supabase
      .from('project_invitations')
      .insert([invitationData])
      .select(`
        *,
        project:tasks!project_invitations_project_id_fkey(
          id,
          title
        ),
        inviter:users!project_invitations_invited_by_fkey(
          id,
          first_name,
          last_name,
          email
        )
      `)
      .single();
    
    if (error) {
      console.error('Supabase error creating invitation:', error);
      return { error: error.message || 'Failed to create invitation' };
    }
    
    console.log('Invitation created successfully:', data);
    return { data };
  } catch (err) {
    console.error('Error creating invitation:', err);
    return { error: err.message || 'Unknown error occurred' };
  }
};
/**
 * Get all invitations sent by a specific user across all projects
 * @param {string} userId - ID of the user who sent the invitations
 * @returns {Promise<{data: Array, error: string}>} - List of sent invitations or error
 */
export const getInvitationsSentByUser = async (userId) => {
    try {
      console.log('Fetching invitations sent by user:', userId);
      
      if (!userId) {
        return { error: 'User ID is required' };
      }
      
      const { data, error } = await supabase
        .from('project_invitations')
        .select('*')
        .eq('invited_by', userId)
        .order('created_at', { ascending: false });
      
      if (error) {
        console.error('Error fetching sent invitations:', error);
        return { error: error.message || 'Failed to fetch sent invitations' };
      }
      
      console.log('Found sent invitations:', data);
      return { data: data || [] };
    } catch (err) {
      console.error('Error fetching sent invitations:', err);
      return { error: err.message || 'Unknown error occurred' };
    }
  };
/**
 * Get all pending invitations for a project
 * @param {string} projectId - ID of the project
 * @returns {Promise<{data: Array, error: string}>} - List of pending invitations or error
 */
export const getProjectInvitations = async (projectId) => {
  try {
    console.log('Fetching invitations for project:', projectId);
    
    if (!projectId) {
      return { error: 'Project ID is required' };
    }
    
    const { data, error } = await supabase
      .from('project_invitations')
      .select('*')
      .eq('project_id', projectId)
      .order('created_at', { ascending: false });
    
    if (error) {
      console.error('Error fetching project invitations:', error);
      return { error: error.message || 'Failed to fetch invitations' };
    }
    
    return { data: data || [] };
  } catch (err) {
    console.error('Error fetching project invitations:', err);
    return { error: err.message || 'Unknown error occurred' };
  }
};

/**
 * Get all pending invitations for a user by email
 * @param {string} email - Email address of the user
 * @returns {Promise<{data: Array, error: string}>} - List of pending invitations or error
 */
export const getPendingInvitationsForUser = async (email) => {
  try {
    console.log('Fetching pending invitations for user:', email);
    
    if (!email) {
      return { error: 'Email is required' };
    }
    
    const { data, error } = await supabase
      .from('project_invitations')
      .select(`
        *,
        project:tasks!project_invitations_project_id_fkey(
          id,
          title,
          description
        ),
        inviter:users!project_invitations_invited_by_fkey(
          id,
          first_name,
          last_name,
          email
        )
      `)
      .eq('email', email.toLowerCase())
      .eq('status', 'pending')
      .gt('expires_at', new Date().toISOString()) // Only non-expired invitations
      .order('created_at', { ascending: false });
    
    if (error) {
      console.error('Error fetching user invitations:', error);
      return { error: error.message || 'Failed to fetch invitations' };
    }
    
    return { data: data || [] };
  } catch (err) {
    console.error('Error fetching user invitations:', err);
    return { error: err.message || 'Unknown error occurred' };
  }
};

/**
 * Accept a project invitation (simplified - using invitation ID instead of token)
 * @param {string} invitationId - The invitation ID
 * @param {string} userId - ID of the user accepting the invitation
 * @returns {Promise<{data: Object, error: string}>} - Success result or error
 */
export const acceptInvitation = async (invitationId, userId) => {
  try {
    console.log('Accepting invitation:', { invitationId, userId });
    
    if (!invitationId || !userId) {
      return { error: 'Invitation ID and user ID are required' };
    }
    
    // Find the invitation
    const { data: invitation, error: inviteError } = await supabase
      .from('project_invitations')
      .select('*')
      .eq('id', invitationId)
      .eq('status', 'pending')
      .single();
    
    if (inviteError) {
      console.error('Error finding invitation:', inviteError);
      if (inviteError.code === 'PGRST116') {
        return { error: 'Invalid or expired invitation' };
      }
      return { error: 'Error validating invitation' };
    }
    
    // Check if invitation has expired
    if (new Date(invitation.expires_at) < new Date()) {
      // Mark as expired
      await supabase
        .from('project_invitations')
        .update({ status: 'expired' })
        .eq('id', invitation.id);
      
      return { error: 'This invitation has expired' };
    }
    
    // Get user email to verify it matches the invitation
    const { data: user, error: userError } = await supabase
      .from('users')
      .select('email')
      .eq('id', userId)
      .single();
    
    if (userError || !user) {
      return { error: 'User not found' };
    }
    
    if (user.email.toLowerCase() !== invitation.email.toLowerCase()) {
      return { error: 'This invitation was sent to a different email address' };
    }
    
    // Check if user is already a member
    const { data: existingMember, error: memberError } = await supabase
      .from('project_memberships')
      .select('id')
      .eq('project_id', invitation.project_id)
      .eq('user_id', userId)
      .single();
    
    if (memberError && memberError.code !== 'PGRST116') {
      return { error: 'Error checking existing membership' };
    }
    
    if (existingMember) {
      // User is already a member, just mark invitation as accepted
      await supabase
        .from('project_invitations')
        .update({ 
          status: 'accepted',
          accepted_at: new Date().toISOString()
        })
        .eq('id', invitation.id);
      
      return { error: 'You are already a member of this project' };
    }
    
    // Create the membership and update invitation in a transaction-like approach
    const { data: membership, error: membershipError } = await supabase
      .from('project_memberships')
      .insert([{
        project_id: invitation.project_id,
        user_id: userId,
        role: invitation.role,
        invited_by: invitation.invited_by,
        invited_at: invitation.created_at,
        accepted_at: new Date().toISOString(),
        status: 'accepted'
      }])
      .select()
      .single();
    
    if (membershipError) {
      console.error('Error creating membership:', membershipError);
      return { error: 'Failed to join project' };
    }
    
    // Update invitation status
    const { error: updateError } = await supabase
      .from('project_invitations')
      .update({ 
        status: 'accepted',
        accepted_at: new Date().toISOString()
      })
      .eq('id', invitation.id);
    
    if (updateError) {
      console.error('Error updating invitation status:', updateError);
      // Membership was created successfully, so don't return error
    }
    
    console.log('Invitation accepted successfully:', membership);
    return { 
      data: {
        membership,
        invitation,
        projectId: invitation.project_id
      }
    };
  } catch (err) {
    console.error('Error accepting invitation:', err);
    return { error: err.message || 'Unknown error occurred' };
  }
};

/**
 * Decline a project invitation (simplified - using invitation ID)
 * @param {string} invitationId - The invitation ID
 * @returns {Promise<{data: Object, error: string}>} - Success result or error
 */
export const declineInvitation = async (invitationId) => {
  try {
    console.log('Declining invitation:', invitationId);
    
    if (!invitationId) {
      return { error: 'Invitation ID is required' };
    }
    
    // Find and update the invitation
    const { data, error } = await supabase
      .from('project_invitations')
      .update({ status: 'declined' })
      .eq('id', invitationId)
      .eq('status', 'pending')
      .select()
      .single();
    
    if (error) {
      console.error('Error declining invitation:', error);
      if (error.code === 'PGRST116') {
        return { error: 'Invalid or already processed invitation' };
      }
      return { error: 'Failed to decline invitation' };
    }
    
    console.log('Invitation declined successfully:', data);
    return { data };
  } catch (err) {
    console.error('Error declining invitation:', err);
    return { error: err.message || 'Unknown error occurred' };
  }
};

/**
 * Revoke/cancel a project invitation
 * @param {string} invitationId - ID of the invitation to revoke
 * @param {string} revokedBy - ID of user revoking the invitation
 * @returns {Promise<{data: Object, error: string}>} - Success result or error
 */
export const revokeInvitation = async (invitationId, revokedBy) => {
  try {
    console.log('Revoking invitation:', { invitationId, revokedBy });
    
    if (!invitationId || !revokedBy) {
      return { error: 'Invitation ID and user ID are required' };
    }
    
    // Update invitation status
    const { data, error } = await supabase
      .from('project_invitations')
      .update({ 
        status: 'revoked',
        updated_at: new Date().toISOString()
      })
      .eq('id', invitationId)
      .eq('status', 'pending') // Can only revoke pending invitations
      .select()
      .single();
    
    if (error) {
      console.error('Error revoking invitation:', error);
      if (error.code === 'PGRST116') {
        return { error: 'Invitation not found or already processed' };
      }
      return { error: 'Failed to revoke invitation' };
    }
    
    console.log('Invitation revoked successfully:', data);
    return { data };
  } catch (err) {
    console.error('Error revoking invitation:', err);
    return { error: err.message || 'Unknown error occurred' };
  }
};

// Remove these token-based functions since we're not using them:
// - getInvitationByToken
// - resendInvitation (since it was token-focused)

const invitationService = {
  createInvitation,
  getProjectInvitations,
  getPendingInvitationsForUser,
  acceptInvitation,
  declineInvitation,
  revokeInvitation,
  getInvitationsSentByUser,
};

export default invitationService;